import json


class CodeBlock:
    def __init__(self):
        self.body = ""

    def set_body(self, body: str, tabs: int):
        self.body = "\t" * tabs + body.replace("\n", "\n" + "\t" * tabs)

    def add_body(self, body_fragment: str, tabs: int):
        if self.body != "":
            self.body += "\n"
        self.body += "\t" * tabs + body_fragment.replace("\n", "\n" + "\t" * tabs)


class IfBlock(CodeBlock):
    def __init__(self):
        CodeBlock.__init__(self)
        self.conditions = []
        self.body = ""

    def add_condition(self, condition: str):
        self.conditions.append(condition)

    def to_string(self):
        and_condition = ""
        for c in self.conditions:
            and_condition += c + " && "
        if and_condition.endswith(" && "):
            and_condition = and_condition[:-len(" && ")]
        body = "{\n" + self.body + "\n}"
        return f"if({and_condition}) {body}"


class FunctionBlock(CodeBlock):
    def __init__(self):
        CodeBlock.__init__(self)
        self.prototype = ""
        self.body = ""

    def set_prototype(self, prototype: str):
        self.prototype = prototype

    def to_string(self):
        body = "{\n" + self.body + "\n}"
        return f"{self.prototype} {body}"


OUT_FILE_HEADER = """
/**
 * Do not edit this file manually!
 * This file is automatically generated by generate_auto_rules.py
 */


#include "ebpf_ids_common.h"


"""


def tcp_rule_to_if_block(rule):
    if_block = IfBlock()
    for key in rule.keys():
        if key == "sourcePort":
            if_block.add_condition(
                "be16_to_cpu(tcp_header->source) == {}".format(rule[key])
            )
        elif key == "destinationPort":
            if_block.add_condition(
                "be16_to_cpu(tcp_header->dest) == {}".format(rule[key])
            )
        elif key == "sourceIp":
            if_block.add_condition(
                "ip_header->saddr == IPADDR_BE({})".format(rule[key].replace(".", ","))
            )
        elif key == "destinationIp":
            if_block.add_condition(
                "ip_header->daddr == IPADDR_BE({})".format(rule[key].replace(".", ","))
            )
        elif key == "idsLevel":
            if_block.set_body("return IDS_LEVEL({});".format(rule[key]), 1)
        elif key == "protocol":
            pass
        else:
            print(f"Unknown key {key}")
    return if_block.to_string()


def udp_rule_to_if_block(rule):
    return tcp_rule_to_if_block(rule).replace("tcp_header", "udp_header")


def generate_tcp_function(rules_tcp):
    fb = FunctionBlock()
    fb.set_prototype("static inline uint32_t\n__auto_rules_tcp(struct bpfhv_pkt* pkt)")
    fb.add_body(
        "struct iphdr* ip_header = get_ip_header(pkt);\n" +
        "struct tcphdr* tcp_header = get_tcp_header(pkt);",
        1
    )
    for rule in rules_tcp:
        if_block_str = tcp_rule_to_if_block(rule)
        fb.add_body(if_block_str, 1)
    fb.add_body("return IDS_PASS;", 1)
    return fb.to_string()


def generate_udp_function(rules_tcp):
    fb = FunctionBlock()
    fb.set_prototype("static inline uint32_t\n__auto_rules_udp(struct bpfhv_pkt* pkt)")
    fb.add_body(
        "struct iphdr* ip_header = get_ip_header(pkt);\n" +
        "struct udphdr* udp_header = get_udp_header(pkt);",
        1
    )
    for rule in rules_tcp:
        if_block_str = udp_rule_to_if_block(rule)
        fb.add_body(if_block_str, 1)
    fb.add_body("return IDS_PASS;", 1)
    return fb.to_string()


def main():
    infile = open("auto_rules.json", "r")
    rule_array = json.loads(infile.read())
    infile.close()
    rules_tcp = [x for x in rule_array if x["protocol"].lower() == "tcp"]
    rules_udp = [x for x in rule_array if x["protocol"].lower() == "udp"]
    print(str(rules_tcp))
    print(str(rules_udp))
    outfile = open("auto_rules.h", "w")
    outfile.write(OUT_FILE_HEADER)
    outfile.write(generate_tcp_function(rules_tcp))
    outfile.write("\n\n")
    outfile.write(generate_udp_function(rules_udp))
    outfile.write("\n\n")
    outfile.close()
    print("Done!")


if __name__ == "__main__":
    main()
